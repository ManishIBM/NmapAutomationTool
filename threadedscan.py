import logging
import nmapscan
import concurrent.futures
import outputfileanalysis
import configInfo
from time import  sleep
import copy
import pickle

#def LogSetup():

'''logIPScan = logging.getLogger('IPScanLog')
logIPScan.setLevel(logging.INFO)

#TODO: get from config file
logIPFile = logging.FileHandler(objConfig.GetConfigParamValue('URI', 'logfileuri'), mode='w')
logIPFile.setLevel(logging.INFO)

logIPStream = logging.StreamHandler()
logIPStream.setLevel(logging.ERROR)

formatter =  logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logIPFile.setFormatter(formatter)
logIPStream.setFormatter(formatter)

logIPScan.addHandler(logIPFile)
logIPScan.addHandler(logIPStream)'''

#module_logger = logging.getLogger('IPScanLog.HostIPScan')

'''class ScanProgess():
    ips = []'''

class MultiThreadedIPScan():
    staticScannedIps = {}
    def __init__(self, IPs = []):
        self.IPs = IPs
        self.scannedIPs = {}
        
        self.scanResultFile = ''
        
        self.log = logging.getLogger('IPScanLog.HostIPScan')
        self.log.info('IPScan log started')
        
        tempScanObj = nmapscan.NmapScan()
        #Get ouput file path generated by nmap 
        self.outputPath = tempScanObj.GetOPPath()
        #initialize object
        self.objExtractPorts = outputfileanalysis.ExtractPorts()
        #Get path where the state of IP scan would searlized
        objConfig = configInfo.ConfigInfo()
        self.serailizeScanFile = objConfig.GetConfigParamValue('URI', 'scanstate')
        self.maxPortThread = int(objConfig.GetConfigParamValue('THREADS', 'maxportthread'))
        self.maxIPThread = int (objConfig.GetConfigParamValue('THREADS', 'maxipthread'))
        self.init = False
        
        
    def FindPortsOfIPs(self):
        self.ReadOpFile()
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.maxIPThread) as executor:
            
            #future_to_scan = {executor.submit(self.scanObj.StartScan(), ip, 60): ip for ip in self.IPs}
            future_to_scan = []
            ipsToScan = []
            ipIndex = 0
            tempDict = {}
            for ip in self.IPs:
                #future_to_scan[ipIndex] = executor.submit(self.PortScan, ip)
                if len(self.scannedIPs) > 0:
                    self.init = True
                    if ip in self.scannedIPs.keys():
                        if self.IsIPScanned(self.scannedIPs[ip]):
                            continue
                        else:
                            self.FindSvcOs(ip, self.scannedIPs[ip])
                            continue

                futureObj = executor.submit(self.PortScan, ip)
                future_to_scan.append(futureObj)
                
                ipsToScan.append(ip)
                ipIndex = ipIndex + 1
                #logging.info('IP %s: Submitted for port scan', ip)
            
            for completedScan in concurrent.futures.as_completed(future_to_scan):
                ipIndex = future_to_scan.index(completedScan)
                self.log.info('IP %s: port scan completed', ipsToScan[ipIndex])
                
                filePath = self.outputPath.joinpath(ipsToScan[ipIndex])
                fileName = filePath.joinpath(ipsToScan[ipIndex]+'.txt')
                
                self.log.info('Start of port extraction from file %s:', fileName)
                ports = self.objExtractPorts.getTCPOpenPorts(fileName)
                
                tempDict = tempDict.fromkeys(ports)
                self.log.info('open ports are %s:', ports)
                self.scannedIPs[ipsToScan[ipIndex]] =  tempDict
                self.NotifyAndUpdate()
                self.FindSvcOs(ipsToScan[ipIndex], ports)
                
            self.log.info('Ip and ports %s', self.scannedIPs)
        
        self.pointer.scanDone.connect(self.pointer.ScanFinishAct)
        self.pointer.scanDone.emit()
        return self.scannedIPs

    def PortScan(self, ip):
        #return
        scanObj = nmapscan.NmapScan()
        scanObj.StartPortScan(ip)
        
        self.log.info('PortScan completed for IP: %s', ip)
        
    def SetConditionalLock(self, lock4File):
        self.threadLock = lock4File

    def FindSvcOs(self, ip, ports):
        #TODO: get the max number of thread from configuration
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.maxPortThread) as executor:
            future_to_scan = []
            portToScan= []
            for port in ports:
                if self.scannedIPs[ip][port]:
                    continue
                portToScan.append(port)
                futureObj = executor.submit(self.SvcOsScan, ip, port)
                future_to_scan.append(futureObj)
                
            for completedScan in concurrent.futures.as_completed(future_to_scan):
                portIndex = future_to_scan.index(completedScan)
                self.scannedIPs[ip][portToScan[portIndex]] = True
                self.log.info('Service and OS scan of Port %s: completed', portToScan[portIndex]) 
                self.NotifyAndUpdate()
                self.WriteOpFile()
         
    def SvcOsScan(self, ip, port):
        '''sleep(5)
        return'''
        scanObj = nmapscan.NmapScan()
        scanObj.StartOsSvcScan(ip, port)
        
    def WriteOpFile(self):
        if len(self.serailizeScanFile) > 0:
            try:
                self.threadLock.acquire()
                with open(self.serailizeScanFile, 'wb') as fileHandle:
                    pickle.dump(self.scannedIPs, fileHandle, protocol=pickle.HIGHEST_PROTOCOL)
                fileHandle.close()
            except FileNotFoundError:
                logging.info("Failed to write content in file")
            #self.threadLock.notifyAll()
            self.threadLock.release()
            sleep(2)
            
            
    def ReadOpFile(self):
        if len(self.serailizeScanFile) <= 0:
            return
        #self.threadLock.acquire()
        try:
            with open(self.serailizeScanFile, 'rb') as fileHandle:
                try:
                    self.scannedIPs = pickle.load(fileHandle)
                    fileHandle.close()
                    return self.scannedIPs
                except EOFError:
                    return {}
                
        except FileNotFoundError:
            self.log.info('Statefile: %s does not exist', self.serailizeScanFile)
            return {}
        #self.threadLock.release()
            
    def NotifyAndUpdate(self):
        self.threadLock.acquire()
        
        MultiThreadedIPScan.staticScannedIps = copy.copy(self.scannedIPs)
        
        #self.threadLock.notifyAll()
        self.threadLock.release()
        
        self.pointer.trigger.connect(self.pointer.UpdateWidgets)
        self.pointer.trigger.emit()
        #sleep(1)
        
    def GetScannedIPUpdate(self):
        return MultiThreadedIPScan.staticScannedIps
    
    def SetPointer(self, pointer):
        self.pointer = pointer
        
    def IsIPScanned(self, dicPorts):
        count = 0
        for port, flag in dicPorts.items():
            if flag == True:
                count = count+1
        if count == len(dicPorts):
            return True
        return False
    


        